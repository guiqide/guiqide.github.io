---
title: 前端加密[密码:skateboy]
published: 2025-12-4 16:44:00
encrypted: true
password: skateboy
category: 前端
---
****
# 前端加密浅谈

## 引言、为什么需要前端加密
我相信很多做过前端的开发者，都听说过前端不安全这种说法，但并不是所有人都试过亲手去实现一个前端所能达到的最安全加密方案，并尝试破解。
某些时候，我们希望产品尽量简单，比如博客、官网这种更新频率低，维护成本小，往往会采用SGO方案。但随着产品迭代，突然需要实现一个简单的加密，让有密码的才允许访问特定文章。这时我们都会再次想起那个心底的疑问：前端加密真的不安全吗？我们今天就来一步步实现一个前端加密，并通过打包后的代码分析来尝试破解，看是否能够成功。

## 加密
### 加解密方案选择
我们在不考虑后端的情况下，需要选择一种加密方案，目前已有成熟的加密算法包括：哈希（不可逆）、对称加密、非对称加密。
1. 首先我们的源文需要在源码时为加密状态，防止用户直接通过源码看到内容，且我们没有后端支持，这里只能采用对称加密
2. 我们的密码源文可以放在build环节进行加密，并通过不可逆哈希进行加密后存储
3. 为了防止黑客因为原码过简单导致直接通过暴力破解，可在加密过程引入PBKDF2
4. 在用户访问时，用户输入密码后，比较是否用户输入的哈希不可逆算法一致，再通过PBKDF2的参数进行解密”密码“
5. 然后通过”密码“解密源文，最后将源文输出到页面

### 加密过程
a. 密码加密
我们从代码中可以看到一串类似密码的hash：$2b$10$iEenW/NAdGU/qOdVU1Q79uj6iVxJ/PyvmmzTaff9uXUkRLDjpIsk6
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031439319.png)
这里稍微展开介绍一下bcrypt，也就是不可逆哈希算法，它不是加密（encryption），而是密码哈希（password hashing）。
这意味着：
- bcrypt（使用的不可逆哈希库）的结果无法解密回原密码
- 验证密码时必须：
  - 使用同样的算法对输入再哈希
  - 然后对比结果是否一致
  - 这和AES、RSA这种可逆加密完全不同。

| 部分 | 含义 |
|------|------|
| 2b$ | bcrypt 版本 |
| 10$ | cost（迭代次数）|
| iEenW/NAdGU/qOdVU1Q79u | 盐(固定22个字符) |
| j6iVxJ/PyvmmzTaff9uXUkRLDjpIsk6 | hash |

b. 源文加密
设想：黑客通过手段跳过密码一致判断阶段，直接通过暴力破解密文，如果恰巧密码设置的很简单
比如用了密码 123456，我们虽然用了 bcrypt 做验证，但攻击者在分析 AES 时：
- AES key = "123456"
- AES-CBC 解密尝试速度：每秒数十万次到数百万次
- 几秒钟就 brute force 出原文
bcrypt 的存在对 AES 加密部分没有任何帮助。
bcrypt 用于验证，不用于生成 AES 密钥。
所以 AES 密钥应该由 PBKDF2 派生出来。

![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031450023.png)
```
// 生成随机 salt (16 字节 = 128 位)
const salt = CryptoJS.lib.WordArray.random(16);

// 使用 PBKDF2 从密码派生密钥 (256 位密钥，100000 次迭代)
const key = CryptoJS.PBKDF2(password, salt, {
  keySize: 256 / 32,  // 256 位
  iterations: 100000,
  hasher: CryptoJS.algo.SHA256
});

// 生成随机 IV
const iv = CryptoJS.lib.WordArray.random(16);

// 使用派生密钥和 IV 加密内容
const encrypted = CryptoJS.AES.encrypt(body, key, {
  iv: iv,
  mode: CryptoJS.mode.CBC,
  padding: CryptoJS.pad.Pkcs7
});
```
打包时将这些加密好的信息存在当前文章页内
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031437909.png)

### 最终效果
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031454179.png)

文章主要讨论加解密，这里忽略了代码实现细节，如果对 astro 下如何实现打包时加密，以及弹窗组件开发，可查看我的博客源码。
- 加密 [https://github.com/guiqide/guiqide.github.io/blob/main/src/pages/posts/%5B...slug%5D.astro](https://github.com/guiqide/guiqide.github.io/blob/main/src/pages/posts/%5B...slug%5D.astro)
- 组件弹窗 [https://github.com/guiqide/guiqide.github.io/blob/main/src/components/PasswordProtection.astro](https://github.com/guiqide/guiqide.github.io/blob/main/src/components/PasswordProtection.astro)

## 破解
首先需要找一个非chrome最新版的浏览器，或者其他一些使用chromium内核的国产浏览器，比如115，因为最新的通常会通过分析页面，如果包含敏感信息（可能的加解密）禁止使用开发者工具
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031538700.png)
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031538915.png)

这里注意，isValidPassword是const，所以覆盖是无效的，尽管在控制台执行了命令，并检查是true，但其实不是一个作用于。需要覆盖校验函数：
```
dcodeIO.bcrypt.compareSync = () => true
```

走到这一步，已经绕过了密码判断的逻辑，但因为文章是通过密码加密的，所以走到这一步，还是无法获取文章内容，黑客在decrypt时需要key，而这个key由真实密码生成的，所以对方想获得源文需要，拿字典暴力尝试生成key，再去尝试AES解源文。是绕不开离线破解这一步，这样难度就取决于原密码的安全性了，只要非弱密码，可能要跑数年。

## 结论

综上所述，前端加密的“安全性”只要选择合理的加密步骤，剩下的就取决于密码本身的强度。虽然黑客理论上可以绕过前端校验，但数据主体依然是用安全算法（AES + PBKDF2）加密的，对方如果没有你设置的强密码，想要穷举出解密密钥几乎不现实。

当然，前端加密适合保护内容安全，但它不是万能的防线——比如面对具有物理访问权限或者服务器泄漏的场景时可能失效；另外也无法防止被获悉密码后泄漏数据。但只要管理好密码，并避免使用弱口令，前端加密依然是提升个人或小型项目安全性的实用手段。