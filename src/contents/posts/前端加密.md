---
title: 前端加密[密码:skateboy]
published: 2025-12-3 9:59:00
encrypted: true
password: skateboy
category: 前端
---
****
# 前端加密浅谈

## 引言、为什么需要前端加密
我相信很多做过前端的开发者，都听说过前端不安全这种说法，但并不是所有人都试过亲手去实现一个前端所能达到的最安全加密方案，并了解如何破解。
某些时候，我们希望产品尽量简单，比如博客、官网这种更新频率低，维护成本小，往往会采用SGO方案。但随着产品迭代，突然需要实现一个简单的加密，让有密码的才允许访问特定文章。这时我们都会再次想起那个心底的疑问：前端加密真的不安全吗？我们今天就来一步步实现一个前端加密，并通过打包后的代码分析来一步步破解这个密码。

## 加密
### 加解密方案选择
我们在不考虑后端的情况下，需要选择一种加密方案，目前已有成熟的加密算法包括：哈希（不可逆）、对称加密、非对称加密。
1. 首先我们的源文需要在源码时为加密状态，防止用户直接通过源码看到内容，且我们没有后端支持，这里只能采用对称加密
2. 我们的密码源文可以放在build环节进行加密，并通过不可逆哈希进行加密后存储
3. 为了防止黑客因为原码过简单导致直接通过暴力破解，可在加密过程引入PBKDF2
4. 在用户访问时，用户输入密码后，比较是否用户输入的哈希不可逆算法一致，再通过PBKDF2的参数进行解密”密码“
5. 然后通过”密码“解密源文，最后将源文输出到页面

### 加密过程
a. 密码加密
我们从代码中可以看到一串类似密码的hash：$2b$10$iEenW/NAdGU/qOdVU1Q79uj6iVxJ/PyvmmzTaff9uXUkRLDjpIsk6
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031439319.png)
这里稍微展开介绍一下bcrypt，也就是不可逆哈希算法，它不是加密（encryption），而是密码哈希（password hashing）。
这意味着：
- bcrypt（使用的不可逆哈希库）的结果无法解密回原密码
- 验证密码时必须：
  - 使用同样的算法对输入再哈希
  - 然后对比结果是否一致
  - 这和AES、RSA这种可逆加密完全不同。

| 部分 | 含义 |
|------|------|
| 2b$ | bcrypt 版本 |
| 10$ | cost（迭代次数）|
| iEenW/NAdGU/qOdVU1Q79u | 盐(固定22个字符) |
| j6iVxJ/PyvmmzTaff9uXUkRLDjpIsk6 | hash |

b. 源文加密
设想：黑客通过手段跳过密码一致判断阶段，直接通过暴力破解密文，如果恰巧密码设置的很简单
比如用了密码 123456，我们虽然用了 bcrypt 做验证，但攻击者在分析 AES 时：
- AES key = "123456"
- AES-CBC 解密尝试速度：每秒数十万次到数百万次
- 几秒钟就 brute force 出原文
bcrypt 的存在对 AES 加密部分没有任何帮助。
bcrypt 用于验证，不用于生成 AES 密钥。
所以 AES 密钥应该由 PBKDF2 派生出来。

![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031450023.png)
```
// 生成随机 salt (16 字节 = 128 位)
const salt = CryptoJS.lib.WordArray.random(16);

// 使用 PBKDF2 从密码派生密钥 (256 位密钥，100000 次迭代)
const key = CryptoJS.PBKDF2(password, salt, {
  keySize: 256 / 32,  // 256 位
  iterations: 100000,
  hasher: CryptoJS.algo.SHA256
});

// 生成随机 IV
const iv = CryptoJS.lib.WordArray.random(16);

// 使用派生密钥和 IV 加密内容
const encrypted = CryptoJS.AES.encrypt(body, key, {
  iv: iv,
  mode: CryptoJS.mode.CBC,
  padding: CryptoJS.pad.Pkcs7
});
```
打包时将这些加密好的信息存在当前文章页内
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031437909.png)

### 最终效果
![](https://images-service-1251417320.cos.ap-guangzhou.myqcloud.com/images/202512031454179.png)

文章主要讨论加解密，这里忽略了代码实现细节，如果对 astro 下如何实现打包时加密，以及弹窗组件开发，可查看我的博客源码。
- 加密 [https://github.com/guiqide/guiqide.github.io/blob/main/src/pages/posts/%5B...slug%5D.astro](https://github.com/guiqide/guiqide.github.io/blob/main/src/pages/posts/%5B...slug%5D.astro)
- 组件弹窗 [https://github.com/guiqide/guiqide.github.io/blob/main/src/components/PasswordProtection.astro](https://github.com/guiqide/guiqide.github.io/blob/main/src/components/PasswordProtection.astro)

## 破解

### 分析源码

### 伪造密码

### 最终效果